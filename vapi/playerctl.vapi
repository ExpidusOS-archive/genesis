/* playerctl.vapi generated by vapigen, do not modify. */

[CCode (cprefix = "Playerctl", gir_namespace = "Playerctl", gir_version = "2.0", lower_case_cprefix = "playerctl_")]
namespace Playerctl {
	[CCode (cheader_filename = "playerctl.h", type_id = "playerctl_player_get_type ()")]
	public class Player : GLib.Object {
		[CCode (has_construct_function = false)]
		public Player (string? player_name) throws GLib.Error;
		[CCode (has_construct_function = false)]
		public Player.for_source (string? player_name, Playerctl.Source source) throws GLib.Error;
		[CCode (has_construct_function = false)]
		public Player.from_name (Playerctl.PlayerName player_name) throws GLib.Error;
		public string get_album () throws GLib.Error;
		public string get_artist () throws GLib.Error;
		public int64 get_position () throws GLib.Error;
		public string get_title () throws GLib.Error;
		public void next () throws GLib.Error;
		[Version (deprecated = true, deprecated_since = "2.0.0")]
		public void on (string event, GLib.Closure callback) throws GLib.Error;
		public void open (string uri) throws GLib.Error;
		public void play_pause () throws GLib.Error;
		public void previous () throws GLib.Error;
		public string print_metadata_prop (string? property) throws GLib.Error;
		public void seek (int64 offset) throws GLib.Error;
		public void set_loop_status (Playerctl.LoopStatus status) throws GLib.Error;
		public void set_position (int64 position) throws GLib.Error;
		public void set_shuffle (bool shuffle) throws GLib.Error;
		public void set_volume (double volume) throws GLib.Error;
		[NoAccessorMethod]
		public bool can_control { get; }
		[NoAccessorMethod]
		public bool can_go_next { get; }
		[NoAccessorMethod]
		public bool can_go_previous { get; }
		[NoAccessorMethod]
		public bool can_pause { get; }
		[NoAccessorMethod]
		public bool can_play { get; }
		[NoAccessorMethod]
		public bool can_seek { get; }
		[NoAccessorMethod]
		public Playerctl.LoopStatus loop_status { get; }
		[NoAccessorMethod]
		public GLib.Variant metadata { owned get; }
		[NoAccessorMethod]
		public Playerctl.PlaybackStatus playback_status { get; }
		[NoAccessorMethod]
		public string player_instance { owned get; construct; }
		[NoAccessorMethod]
		public string player_name { owned get; construct; }
		[NoAccessorMethod]
		public int64 position { get; }
		[NoAccessorMethod]
		public bool shuffle { get; }
		[NoAccessorMethod]
		public Playerctl.Source source { get; construct; }
		[NoAccessorMethod]
		[Version (deprecated = true, deprecated_since = "2.0.0")]
		public string status { owned get; }
		[NoAccessorMethod]
		public double volume { get; set; }
		public signal void exit ();
		[HasEmitter]
		[Version (deprecated = true, deprecated_since = "2.0.0")]
		public signal void pause ();
		[HasEmitter]
		[Version (deprecated = true, deprecated_since = "2.0.0")]
		public signal void play ();
		public signal void seeked (int64 position);
		[HasEmitter]
		[Version (deprecated = true, deprecated_since = "2.0.0")]
		public signal void stop ();
	}
	[CCode (cheader_filename = "playerctl.h", type_id = "playerctl_player_manager_get_type ()")]
	public class PlayerManager : GLib.Object {
		[CCode (has_construct_function = false)]
		public PlayerManager () throws GLib.Error;
		public void manage_player (Playerctl.Player player);
		public void move_player_to_top (Playerctl.Player player);
		public void set_sort_func (owned GLib.CompareDataFunc sort_func);
		[NoAccessorMethod]
		public GLib.List<Playerctl.PlayerName> player_names { owned get; }
		[NoAccessorMethod]
		public GLib.List<Playerctl.Player> players { owned get; }
		public signal void name_appeared (Playerctl.PlayerName name);
		public signal void name_vanished (Playerctl.PlayerName name);
		public signal void player_appeared (Playerctl.Player player);
		public signal void player_vanished (Playerctl.Player player);
	}
	[CCode (cheader_filename = "playerctl.h", copy_function = "g_boxed_copy", free_function = "g_boxed_free", type_id = "playerctl_player_name_get_type ()")]
	[Compact]
	public class PlayerName {
		public weak string instance;
		public weak string name;
		public Playerctl.Source source;
		public Playerctl.PlayerName copy ();
		public void free ();
	}
	[CCode (cheader_filename = "playerctl.h", cprefix = "PLAYERCTL_LOOP_STATUS_", type_id = "playerctl_loop_status_get_type ()")]
	public enum LoopStatus {
		NONE,
		TRACK,
		PLAYLIST
	}
	[CCode (cheader_filename = "playerctl.h", cprefix = "PLAYERCTL_PLAYBACK_STATUS_", type_id = "playerctl_playback_status_get_type ()")]
	public enum PlaybackStatus {
		PLAYING,
		PAUSED,
		STOPPED
	}
	[CCode (cheader_filename = "playerctl.h", cprefix = "PLAYERCTL_SOURCE_", type_id = "playerctl_source_get_type ()")]
	public enum Source {
		NONE,
		DBUS_SESSION,
		DBUS_SYSTEM
	}
	[CCode (cheader_filename = "playerctl.h")]
	public static GLib.List<Playerctl.PlayerName> list_players () throws GLib.Error;
}
